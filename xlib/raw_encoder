# HP-41 RAW File Encoder
# Converts XRPN text format to RAW bytecode

def raw_encode(program, label_name = "PROG")
  # Command to opcode mapping (inverse of decoder) - Phase 1 complete
  commands = {
    # Arithmetic
    "+" => [0x81],
    "-" => [0x82],
    "*" => [0x83],
    "/" => [0x84],
    "END" => [0x85],
    "SQRT" => [0x86],
    "CLST" => [0x87],

    # Stack operations
    "ENTER" => [0x88],
    "SWAP" => [0x89],
    "XY" => [0x89],     # Alias for SWAP
    "RDN" => [0x8A],
    "CHS" => [0x8B],
    "LASTX" => [0x8C],
    "CLX" => [0x8D],

    # Display/IO
    "PROMPT" => [0x8E],
    "RTN" => [0x8F],
    "AVIEW" => [0x9B, 0x73],
    "VIEW" => [0x9A, 0x72],
    "PSE" => [0x9C],
    "BEEP" => [0x9D],
    "STOP" => [0x9E],
  }

  result = []
  main_label_written = false

  program.each do |line|
    line = line.strip
    next if line.empty?
    next if line.start_with?("#")  # Skip comments

    # Label definition
    if line =~ /^LBL\s+"(.+)"$/i
      lbl_name = $1
      if !main_label_written
        # First label is global (main entry point)
        result += [0xC0, 0x00, 0xF7, 0x00]  # Global label header
        result += lbl_name.bytes
        main_label_written = true
      else
        # Subsequent labels are local
        result += [0xF6, 0x00]
        result += lbl_name.bytes
      end
      next
    end

    # String literals
    if line =~ /^"(.+)"$/
      text = $1
      result << 0xFD
      result += text.bytes
      next
    end

    # RCL register
    if line =~ /^RCL\s+(\d+)$/i
      reg = $1.to_i
      result += [0xA7, reg]
      next
    end

    # STO register
    if line =~ /^STO\s+(\d+)$/i
      reg = $1.to_i
      result += [0xB2, reg]
      next
    end

    # GTO with label
    if line =~ /^GTO\s+"(.+)"$/i
      label = $1
      result << 0x90
      result += label.bytes
      next
    end

    # XEQ with label
    if line =~ /^XEQ\s+"(.+)"$/i
      label = $1
      result << 0x91
      result += label.bytes
      next
    end

    # Conditionals
    conditionals = {
      "X=0?" => 0x67,
      "X!=0?" => 0x68,
      "X>0?" => 0x69,
      "X<0?" => 0x6A,
      "X>=0?" => 0x6B,
      "X<=0?" => 0x6C,
      "X=Y?" => 0x71,
      "X!=Y?" => 0x72,
      "X>Y?" => 0x73,
      "X<Y?" => 0x74,
      "X>=Y?" => 0x75,
      "X<=Y?" => 0x76,
      "X<>Y?" => 0x78,
    }
    cmd_upper = line.upcase
    if conditionals[cmd_upper]
      result << conditionals[cmd_upper]
      next
    end

    # Flag operations
    if line =~ /^(SF|CF|FS\?|FC\?|FS\?C|FC\?C|FSC\?)\s+(\d+)$/i
      op = $1.upcase
      flag = $2.to_i
      flag_ops = {
        "SF" => 0xA8,
        "CF" => 0xA9,
        "FS?" => 0xAA,
        "FC?" => 0xAB,
        "FS?C" => 0xAC,
        "FC?C" => 0xAD,
        "FSC?" => 0xAE,
      }
      if flag_ops[op]
        result += [flag_ops[op], flag]
        next
      end
    end

    # Single digit literals (0-9)
    if line =~ /^(\d)$/
      digit = $1.to_i
      result += [0xF1, 0x30 + digit]
      next
    end

    # Hex digits (10-15 as A-F)
    if line =~ /^(1[0-5])$/
      val = $1.to_i
      result += [0xF1, 0x41 + (val - 10)]
      next
    end

    # Known commands
    if commands[cmd_upper]
      result += commands[cmd_upper]
      next
    end

    # Unknown command - add as comment in output
    puts "Warning: Cannot encode command: #{line}"
  end

  # Add end marker
  result += [0xC0, 0x02, 0x2F]

  result.pack("C*")
end

# vim:ft=ruby:
