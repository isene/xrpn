# HP-41 RAW File Encoder
# Converts XRPN text format to RAW bytecode

def raw_encode(program, label_name = "PROG")
  # Command to opcode mapping (inverse of decoder) - Phase 1 + 2
  commands = {
    # Arithmetic
    "+" => [0x81],
    "-" => [0x82],
    "*" => [0x83],
    "/" => [0x84],
    "END" => [0x85],
    "SQRT" => [0x86],
    "CLST" => [0x87],

    # Math functions (Phase 4) - Core ROM single-byte opcodes
    # Safe to encode - will appear after operations/numbers (non-ASCII context)
    "LN" => [0x50],
    "X^2" => [0x51],
    "POW" => [0x53],
    "E^X" => [0x55],
    "LOG" => [0x56],
    "10^X" => [0x57],
    "E^X-1" => [0x58],
    "SIN" => [0x59],
    "COS" => [0x5A],
    "TAN" => [0x5B],
    "ASIN" => [0x5C],
    "ACOS" => [0x5D],
    "ATAN" => [0x5E],
    "1/X" => [0x60],
    "ABS" => [0x61],
    "LN1+X" => [0x65],
    "LN1X" => [0x65],  # XRPN alias

    # Stack operations
    "ENTER" => [0x88],
    "SWAP" => [0x89],
    "XY" => [0x89],     # Alias for SWAP
    "RDN" => [0x8A],
    "CHS" => [0x8B],
    "LASTX" => [0x8C],
    "CLX" => [0x8D],

    # Display/IO
    "PROMPT" => [0x8E],
    "RTN" => [0x8F],
    "AVIEW" => [0x9B, 0x73],
    "VIEW" => [0x9A, 0x72],
    "PSE" => [0x9C],
    "BEEP" => [0x9D],
    "STOP" => [0x9E],

    # Extended operations (Phase 2)
    "DEG" => [0x93],
    "RAD" => [0x94],
    "GRAD" => [0x95],
    "FIX" => [0x96],
    "SCI" => [0x97],
    "ENG" => [0x98],
    "ISG" => [0x9F],
  }

  result = []
  main_label_written = false

  program.each do |line|
    line = line.strip
    next if line.empty?
    next if line.start_with?("#")  # Skip comments

    # Label definition
    if line =~ /^LBL\s+"(.+)"$/i
      lbl_name = $1
      if !main_label_written
        # First label is global (main entry point)
        result += [0xC0, 0x00, 0xF7, 0x00]  # Global label header
        result += lbl_name.bytes
        # No terminator needed - next opcode (non-ASCII) terminates naturally
        main_label_written = true
      else
        # Subsequent labels are local
        result += [0xF6, 0x00]
        result += lbl_name.bytes
        # No terminator needed
      end
      next
    end

    # String literals
    if line =~ /^"(.+)"$/
      text = $1
      result << 0xFD
      result += text.bytes
      next
    end

    # RCL register
    if line =~ /^RCL\s+(\d+)$/i
      reg = $1.to_i
      result += [0xA7, reg]
      next
    end

    # STO register
    if line =~ /^STO\s+(\d+)$/i
      reg = $1.to_i
      result += [0xB2, reg]
      next
    end

    # GTO with label
    if line =~ /^GTO\s+"(.+)"$/i
      label = $1
      result << 0x90
      result += label.bytes
      next
    end

    # XEQ with label
    if line =~ /^XEQ\s+"(.+)"$/i
      label = $1
      result << 0x91
      result += label.bytes
      next
    end

    # Conditionals
    conditionals = {
      "X=0?" => 0x67,
      "X!=0?" => 0x68,
      "X>0?" => 0x69,
      "X<0?" => 0x6A,
      "X>=0?" => 0x6B,
      "X<=0?" => 0x6C,
      "X=Y?" => 0x71,
      "X!=Y?" => 0x72,
      "X>Y?" => 0x73,
      "X<Y?" => 0x74,
      "X>=Y?" => 0x75,
      "X<=Y?" => 0x76,
      "X<>Y?" => 0x78,
    }
    cmd_upper = line.upcase
    if conditionals[cmd_upper]
      result << conditionals[cmd_upper]
      next
    end

    # Flag operations
    if line =~ /^(SF|CF|FS\?|FC\?|FS\?C|FC\?C|FSC\?)\s+(\d+)$/i
      op = $1.upcase
      flag = $2.to_i
      flag_ops = {
        "SF" => 0xA8,
        "CF" => 0xA9,
        "FS?" => 0xAA,
        "FC?" => 0xAB,
        "FS?C" => 0xAC,
        "FC?C" => 0xAD,
        "FSC?" => 0xAE,
      }
      if flag_ops[op]
        result += [flag_ops[op], flag]
        next
      end
    end

    # Single digit literals (0-9)
    if line =~ /^(\d)$/
      digit = $1.to_i
      result += [0xF1, 0x30 + digit]
      next
    end

    # Hex digits (10-15 as A-F)
    if line =~ /^(1[0-5])$/
      val = $1.to_i
      result += [0xF1, 0x41 + (val - 10)]
      next
    end

    # XROM extended functions (E0 00 XX)
    xrom_funcs = {
      "ANUM" => [0xE0, 0x00, 0x00],
      "ALENG" => [0xE0, 0x00, 0x01],
      "APPCHR" => [0xE0, 0x00, 0x02],
      "APPREC" => [0xE0, 0x00, 0x03],
      "ARCLREC" => [0xE0, 0x00, 0x04],
      "AROT" => [0xE0, 0x00, 0x05],
      "ATOX" => [0xE0, 0x00, 0x06],
      "CLFL" => [0xE0, 0x00, 0x07],
      "CLKEYS" => [0xE0, 0x00, 0x08],
      "CRFLAS" => [0xE0, 0x00, 0x09],
      "CRFLD" => [0xE0, 0x00, 0x0A],
      "DELCHR" => [0xE0, 0x00, 0x0B],
      "DELREC" => [0xE0, 0x00, 0x0C],
      "EMDIR" => [0xE0, 0x00, 0x0D],
      "FLSIZE" => [0xE0, 0x00, 0x0E],
      "GETAS" => [0xE0, 0x00, 0x0F],
      "GETKEY" => [0xE0, 0x00, 0x10],
      "GETP" => [0xE0, 0x00, 0x11],
      "GETR" => [0xE0, 0x00, 0x12],
      "GETREC" => [0xE0, 0x00, 0x13],
      "GETRX" => [0xE0, 0x00, 0x14],
      "GETSUB" => [0xE0, 0x00, 0x15],
      "GETX" => [0xE0, 0x00, 0x17],
      "INSCHR" => [0xE0, 0x00, 0x1B],
      "INSREC" => [0xE0, 0x00, 0x1F],
      "PASN" => [0xE0, 0x00, 0x20],
      "PCLPS" => [0xE0, 0x00, 0x21],
      "POSA" => [0xE0, 0x00, 0x3A],
      "POSFL" => [0xE0, 0x00, 0x3B],
      "PSIZE" => [0xE0, 0x00, 0x38],
      "PURFL" => [0xE0, 0x00, 0x4E],
      "RCLFLAG" => [0xE0, 0x00, 0x61],
      "RCLPT" => [0xE0, 0x00, 0x62],
      "RCLPTA" => [0xE0, 0x00, 0x63],
      "REGMOVE" => [0xE0, 0x00, 0x66],
      "REGSWAP" => [0xE0, 0x00, 0x67],
      "SAVEAS" => [0xE0, 0x00, 0x68],
      "SAVEP" => [0xE0, 0x00, 0x69],
      "SAVER" => [0xE0, 0x00, 0x7C],
      "SAVERX" => [0xE0, 0x00, 0x7E],
      "SAVEX" => [0xE0, 0x00, 0x7F],
    }
    if xrom_funcs[cmd_upper]
      result += xrom_funcs[cmd_upper]
      next
    end

    # Known commands
    if commands[cmd_upper]
      result += commands[cmd_upper]
      next
    end

    # Unknown command - add as comment in output
    puts "Warning: Cannot encode command: #{line}"
  end

  # Add end marker
  result += [0xC0, 0x02, 0x2F]

  result.pack("C*")
end

# vim:ft=ruby:
