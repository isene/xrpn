# HP-41 RAW File Decoder
# Converts RAW bytecode to XRPN text format

def raw_decode(data)
  # Opcode mapping table (from raw.md documentation + Phase 1)
  opcodes = {
    # Arithmetic
    0x81 => "+",
    0x82 => "-",
    0x83 => "*",
    0x84 => "/",
    0x85 => "END",
    0x86 => "SQRT",
    0x87 => "CLST",  # Clear stack

    # Math functions (Phase 4) - Single-byte but context-sensitive
    # These overlap with ASCII (0x50-0x66) so only valid after non-ASCII bytes
    0x50 => "LN",      # Natural log
    0x51 => "X^2",     # X squared
    0x52 => "SQRT",    # Square root
    0x53 => "POW",     # Y^X
    0x54 => "CHS",     # Change sign (already in 0x8B but also here)
    0x55 => "E^X",     # e to the X
    0x56 => "LOG",     # Base-10 log
    0x57 => "10^X",    # 10 to the X
    0x58 => "E^X-1",   # e^X - 1
    0x59 => "SIN",     # Sine
    0x5A => "COS",     # Cosine
    0x5B => "TAN",     # Tangent
    0x5C => "ASIN",    # Arc sine
    0x5D => "ACOS",    # Arc cosine
    0x5E => "ATAN",    # Arc tangent
    0x60 => "1/X",     # Reciprocal
    0x61 => "ABS",     # Absolute value
    0x65 => "LN1+X",   # ln(1+X)

    # Stack operations
    0x88 => "ENTER",
    0x89 => "SWAP",  # X<>Y
    0x8A => "RDN",   # Roll down
    0x8B => "CHS",   # Change sign
    0x8C => "LASTX",
    0x8D => "CLX",

    # Display/IO operations
    0x80 => "CLA",   # Clear alpha
    0x8E => "PROMPT",
    0x9B => "AVIEW",
    0x9C => "PSE",   # Pause
    0x9D => "BEEP",
    0x9E => "STOP",

    # Extended operations (Phase 2)
    0x92 => "X<>",   # X exchange (with register parameter)
    0x93 => "DEG",   # Degree mode
    0x94 => "RAD",   # Radian mode
    0x95 => "GRAD",  # Gradian mode
    0x96 => "FIX",   # Fix decimal places (parameter follows)
    0x97 => "SCI",   # Scientific notation
    0x98 => "ENG",   # Engineering notation
    0x99 => "RCL",   # RCL variant
    0x9A => "DSE",   # Decrement and skip if equal (with register)
    0x9F => "ISG",   # Increment and skip if greater

    # Flow control
    0x8F => "RTN",   # Return

    # Additional useful opcodes
    0xCE => "ASTO",  # Append string to alpha (with register)
    0x7E => "~",     # Tilde separator
    0x7F => "\"",    # Quote character

    # Arithmetic variants (0x40-0x43)
    0x40 => "+",     # Addition variant
    0x41 => "-",     # Subtraction variant
    0x42 => "*",     # Multiplication variant
    0x43 => "/",     # Division variant

    # Control flow markers (not commands)
    0x00 => nil,  # NOP/padding - handled specially
  }

  result = []
  pos = 0
  in_number_context = false  # Track if we just saw an operation/END

  while pos < data.length
    byte = data[pos].ord

    # Global label header (C0 00 Fx 00 LABELNAME)
    if byte == 0xC0 && pos + 3 < data.length && data[pos + 1].ord == 0x00
      label_type = data[pos + 2].ord
      pos += 4

      # Extract label name (ASCII letters, digits, space 0x20-0x7E)
      label = ""
      while pos < data.length
        b = data[pos].ord
        # Accept alphanumeric and common symbols (0x20-0x7E)
        # But NOT control chars (< 0x20) or high-bit (>= 0x80)
        # Special case: 0x7F (DEL) terminates
        break if b < 0x20 || b >= 0x7F
        label << data[pos]
        pos += 1
      end

      result << "LBL \"#{label}\""
      in_number_context = true  # Numbers can follow labels
      next
    end

    # Variant header (C6 00 Fx 00 LABELNAME)
    if byte == 0xC6 && pos + 3 < data.length && data[pos + 1].ord == 0x00
      pos += 4

      # Extract label name
      label = ""
      while pos < data.length
        b = data[pos].ord
        break if b < 0x20 || b >= 0x7F
        label << data[pos]
        pos += 1
      end

      result << "LBL \"#{label}\""
      in_number_context = true
      next
    end

    # Local label (F6 00 LABELNAME or F6 LABELNAME)
    if byte == 0xF6
      if pos + 1 < data.length && data[pos + 1].ord == 0x00
        pos += 2
      else
        pos += 1
      end

      # Extract label name
      label = ""
      while pos < data.length
        b = data[pos].ord
        break if b < 0x20 || b >= 0x7F
        label << data[pos]
        pos += 1
      end

      result << "LBL \"#{label}\""
      in_number_context = true
      next
    end

    # String literals (various formats)
    # Format: FD TEXT (string literal)
    if byte == 0xFD && pos + 1 < data.length
      pos += 1
      text = ""
      while pos < data.length && data[pos].ord >= 0x20 && data[pos].ord < 0x7F
        text << data[pos]
        pos += 1
      end
      result << "\"#{text}\"" unless text.empty?
      next
    end

    # Format: F5 TEXT (display string after label)
    if byte == 0xF5 && pos > 4 && result.length > 0
      pos += 1
      text = ""
      while pos < data.length && data[pos].ord >= 0x20 && data[pos].ord < 0x7F
        text << data[pos]
        pos += 1
      end
      result << "\"#{text}\"" unless text.empty?
      next
    end

    # Flag operations (A8-AE range) - CHECK BEFORE RCL!
    if byte >= 0xA8 && byte <= 0xAE && pos + 1 < data.length
      flag_num = data[pos + 1].ord
      flag_ops = {
        0xA8 => "SF",   # Set flag
        0xA9 => "CF",   # Clear flag
        0xAA => "FS?",  # Flag set?
        0xAB => "FC?",  # Flag clear?
        0xAC => "FS?C", # Flag set? then clear
        0xAD => "FC?C", # Flag clear? then clear
        0xAE => "FSC?", # Flag set/clear?
      }
      if flag_ops[byte]
        result << "#{flag_ops[byte]} #{flag_num}"
        pos += 2
        next
      end
    end

    # RCL operations (A7 + register number)
    if byte == 0xA7 && pos + 1 < data.length
      reg_num = data[pos + 1].ord
      result << "RCL #{reg_num}"
      pos += 2
      next
    end

    # STO operations (B2-BB range + register number)
    if byte >= 0xB2 && byte <= 0xBB && pos + 1 < data.length
      reg_num = data[pos + 1].ord
      result << "STO #{reg_num}"
      pos += 2
      next
    end

    # VIEW operations (9A-9C variants)
    if byte >= 0x9A && byte <= 0x9C && pos + 1 < data.length
      next_byte = data[pos + 1].ord
      if next_byte == 0x73
        result << "AVIEW"
        pos += 2
      elsif next_byte == 0x72
        result << "VIEW"
        pos += 2
      else
        result << "VIEW #{next_byte}"
        pos += 2
      end
      next
    end

    # GTO (0x90 + label reference or register)
    if byte == 0x90 && pos + 1 < data.length
      next_byte = data[pos + 1].ord
      if next_byte >= 0x41 && next_byte <= 0x5A  # ASCII A-Z
        # Label name follows
        label = ""
        pos += 1
        while pos < data.length && data[pos].ord >= 0x20 && data[pos].ord < 0x7F
          label << data[pos]
          pos += 1
        end
        result << "GTO \"#{label}\""
      else
        result << "GTO #{next_byte}"
        pos += 2
      end
      next
    end

    # XEQ (0x91 + label reference)
    if byte == 0x91 && pos + 1 < data.length
      next_byte = data[pos + 1].ord
      if next_byte >= 0x41 && next_byte <= 0x5A  # ASCII A-Z
        # Label name follows
        label = ""
        pos += 1
        while pos < data.length && data[pos].ord >= 0x20 && data[pos].ord < 0x7F
          label << data[pos]
          pos += 1
        end
        result << "XEQ \"#{label}\""
      else
        result << "XEQ #{next_byte}"
        pos += 2
      end
      next
    end

    # Direct register operations (Phase 5) - Single byte RCL/STO
    # 0x20-0x2F = RCL 00-15, 0x30-0x3F = STO 00-15
    if byte >= 0x20 && byte <= 0x2F && pos > 0
      prev_byte = data[pos - 1].ord
      # Safe if after non-ASCII (avoid being part of strings)
      if prev_byte >= 0x80 || prev_byte <= 0x1F
        reg = byte - 0x20
        result << "RCL #{sprintf('%02d', reg)}"
        pos += 1
        in_number_context = true
        next
      end
    end

    if byte >= 0x30 && byte <= 0x3F && pos > 0
      prev_byte = data[pos - 1].ord
      # Safe if after non-ASCII
      if prev_byte >= 0x80 || prev_byte <= 0x1F
        reg = byte - 0x30
        result << "STO #{sprintf('%02d', reg)}"
        pos += 1
        in_number_context = true
        next
      end
    end

    # Math functions in ASCII range (0x50-0x66) - Phase 4
    # Only decode as math if NOT in label/string context
    # Safe after: opcodes >= 0x80, numbers 0x00-0x1F, END (0x85)
    if byte >= 0x50 && byte <= 0x66 && pos > 0
      prev_byte = data[pos - 1].ord
      # Safe context: after operations, numbers, or non-ASCII
      if prev_byte >= 0x80 || prev_byte <= 0x1F || prev_byte == 0x85
        math_ops = {
          0x50 => "LN",
          0x51 => "X^2",
          0x52 => "SQRT",
          0x53 => "POW",
          0x54 => "CHS",
          0x55 => "E^X",
          0x56 => "LOG",
          0x57 => "10^X",
          0x58 => "E^X-1",
          0x59 => "SIN",
          0x5A => "COS",
          0x5B => "TAN",
          0x5C => "ASIN",
          0x5D => "ACOS",
          0x5E => "ATAN",
          0x60 => "1/X",
          0x61 => "ABS",
          0x65 => "LN1+X",
        }
        if math_ops[byte]
          result << math_ops[byte]
          pos += 1
          in_number_context = true
          next
        end
      end
    end

    # Numeric literals (Phase 5) - 0x00-0x63 = 0-99
    # Safe after: operations (0x80+), END (0x85), labels, or in number context
    if byte >= 0x00 && byte <= 0x63 && pos > 0
      prev_byte = data[pos - 1].ord
      # Multiple safe contexts
      safe_contexts = [
        prev_byte >= 0x80,           # After operations
        prev_byte == 0x85,           # After END
        in_number_context,           # After recent operation
        prev_byte >= 0x00 && prev_byte <= 0x1F  # After another number
      ]

      if safe_contexts.any?
        result << byte.to_s
        pos += 1
        in_number_context = true
        next
      end
    end

    # XROM multi-byte instructions (Phase 3)
    # Format: PREFIX MODULE FUNCTION
    if (byte == 0xE0 || byte == 0xD0 || byte == 0xCF) && pos + 2 < data.length
      prefix = byte
      mod_id = data[pos + 1].ord
      func_id = data[pos + 2].ord

      # E0 = XROM extended functions
      if prefix == 0xE0 && mod_id == 0x00
        xrom_funcs = {
          0x00 => "ANUM",
          0x01 => "ALENG",
          0x02 => "APPCHR",
          0x03 => "APPREC",
          0x04 => "ARCLREC",
          0x05 => "AROT",
          0x06 => "ATOX",
          0x07 => "CLFL",
          0x08 => "CLKEYS",
          0x09 => "CRFLAS",
          0x0A => "CRFLD",
          0x0B => "DELCHR",
          0x0C => "DELREC",
          0x0D => "EMDIR",
          0x0E => "FLSIZE",
          0x0F => "GETAS",
          0x10 => "GETKEY",
          0x11 => "GETP",
          0x12 => "GETR",
          0x13 => "GETREC",
          0x14 => "GETRX",
          0x15 => "GETSUB",
          0x17 => "GETX",
          0x1B => "INSCHR",
          0x1F => "INSREC",
          0x20 => "PASN",
          0x21 => "PCLPS",
          0x3A => "POSA",
          0x3B => "POSFL",
          0x38 => "PSIZE",
          0x4E => "PURFL",
          0x61 => "RCLFLAG",
          0x62 => "RCLPT",
          0x63 => "RCLPTA",
          0x66 => "REGMOVE",
          0x67 => "REGSWAP",
          0x68 => "SAVEAS",
          0x69 => "SAVEP",
          0x7C => "SAVER",
          0x7E => "SAVERX",
          0x7F => "SAVEX",
        }
        if xrom_funcs[func_id]
          result << xrom_funcs[func_id]
          pos += 3
          next
        else
          result << "XROM 00,#{func_id}"
          pos += 3
          next
        end
      end

      # D0 00 = Data/register operations
      if prefix == 0xD0 && mod_id == 0x00
        result << "# D0-OP #{func_id}"
        pos += 3
        next
      end

      # CF = Control flow extended
      if prefix == 0xCF
        result << "# CF-OP #{mod_id},#{func_id}"
        pos += 3
        next
      end

      # Unknown XROM
      result << "# XROM #{mod_id},#{func_id}"
      pos += 3
      next
    end

    # Conditionals (0x67-0x78 range for X comparisons)
    if byte >= 0x67 && byte <= 0x78
      cond_map = {
        0x67 => "X=0?",
        0x68 => "X!=0?",
        0x69 => "X>0?",
        0x6A => "X<0?",
        0x6B => "X>=0?",
        0x6C => "X<=0?",
        0x71 => "X=Y?",
        0x72 => "X!=Y?",
        0x73 => "X>Y?",
        0x74 => "X<Y?",
        0x75 => "X>=Y?",
        0x76 => "X<=Y?",
        0x78 => "X<>Y?",  # X exchange Y test
      }
      if cond_map[byte]
        result << cond_map[byte]
      else
        result << "# Conditional: 0x#{byte.to_s(16).upcase}"
      end
      pos += 1
      next
    end

    # Numeric literals (Phase 4 - EXPERIMENTAL)
    # Numbers 0x00-0x63 (0-99) but only in safe contexts
    # This is tricky because 0x10-0x7F overlaps with ASCII and opcodes
    # For now, skip numeric literal auto-detection to avoid false positives
    # TODO: Need more research on exact number encoding rules

    # Single digit literals via F1 XX (alternate encoding)
    if byte == 0xF1 && pos + 1 < data.length
      digit = data[pos + 1].ord
      if digit >= 0x30 && digit <= 0x39
        result << (digit - 0x30).to_s  # 0-9
      elsif digit >= 0x41 && digit <= 0x46
        result << ((digit - 0x41 + 10)).to_s  # A-F (10-15)
      end
      pos += 2
      next
    end

    # Known single-byte opcodes
    if opcodes[byte]
      result << opcodes[byte]
      pos += 1
      # Set number context for operations that commonly precede numbers
      in_number_context = [0x85, 0x8E].include?(byte)  # After END, PROMPT
      next
    end

    # End markers - stop processing
    if byte == 0xC2 || byte == 0xC8 || byte == 0xCA
      break
    end

    # End marker (C0 02 2F)
    if byte == 0xC0 && pos + 2 < data.length
      if data[pos + 1].ord == 0x02 && data[pos + 2].ord == 0x2F
        break
      end
    end

    # Unknown opcode - output as comment
    if byte > 0x20 && byte < 0x7F
      # Skip - might be part of string
      pos += 1
    else
      result << "# Unknown: 0x#{byte.to_s(16).upcase}"
      pos += 1
    end
  end

  # Remove nil entries and return
  result.compact
end

# vim:ft=ruby:
