#!/usr/bin/env ruby
# encoding: utf-8

# GET EXTENSIONS
require 'optparse'
require 'io/console'
require 'date'
require 'bigdecimal'
require 'open-uri'
require 'json'

# INITIALIZE
@x, @y, @z, @t, @a = 0, 0, 0, 0, ""
Dir[Dir.home+"/.xrpn/lib/*"].each { |file| load file }  # Read libraries
read_cmd                                                # Read XRPN commands
@p = XRPN.new($rfile)
@p.x, @p.y, @p.z, @p.t, @p.a = @x, @y, @z, @t, @a
@p.prg[@p.pg] = ["LBL \"XRPN\"", "END"] unless $rfile   # Put dummy program in page 0 if no file to run
@p.prg[@p.pg] = hp_41(@p.prg[@p.pg]) if $rfile          # Substitute HP-41 commands with XRPN commands
if $lfile                                               # Read file to load but not run if -l switch is used
  $lfile.each_with_index do |f, i|
    @p.prg[i] = File.read(f).split("\n")
    @p.prg[i] = hp_41(@p.prg[i])
  end
end
read_state($sfile) if $sfile                            # Read state file in ~.xrpn/ if -s switch is used
$debug = true      if $lfile or $sfile                  # Do not run loaded program or program in state file
load(Dir.home+'/.xrpn/conf') if File.exist?(Dir.home+'/.xrpn/conf') # Read config file

# THE CORE OF THE RPN PROGRAM
@nl = false # Nolift set to false
@i  = 0     # Counter to prevent infinite loops
until @p.pc == @p.prg[@p.pg].length do
  # Enter debug mode if $debug or $prompt is set, else read next program line
  ($debug or $prompt) ? debug_mode : @line = @p.prg[@p.pg][@p.pc]
  if @line.match(/^-*[\d\.,e]+$/) # If a number is supplied
    @line.sub!(/,/, '.')
    @p.lift
    @p.x = @line.to_f
    @p.flg["22"] = true  # Number has been entered
    @p.flg["23"] = false
  elsif @line.match(/^>?".*"/) # If an Alpha string is supplied 
    if @line.match(/^"\|/)
      @p.a += @line.sub(/\|-?/, '').gsub(/\"/, '') # Append to Alpha if "|abc", "|-abc"
    elsif @line.match(/^>"/)
      @p.a += @line.sub(/>/, '').gsub(/\"/, '')    # Append to Alpha if >"abc"
    else
      @p.a = @line.gsub(/\"/, '') # ...or set Alpha to the supplied string
    end
    @p.flg["22"] = false
    @p.flg["23"] = true  # String has been entered
  else # Split command in maximum three words (e.g. STO IND 13)
    l1, l2, l3 = @line.split[0], @line.split[1], @line.split[2]
    l2 = "%02d" % [l2] if l2 == l2.to_i.to_s
    l3 = "%02d" % [l3] if l3 == l3.to_i.to_s
    l2 = ind(l3) if l3 # If middle word is "IND" (or anything actually - since IND is the only possibility)
    if not $cmd.include?(l1.downcase) # Catch unknown command
      puts "No such command: #{l1}"
      @p.stop
    elsif XRPN.method_defined?(l1.downcase) # Or execute the command with either 1 or 2 parts
      begin
        l2 ? ret = @p.send(l1.downcase, l2) : ret = @p.send(l1.downcase)
      rescue ArgumentError
        puts "Command needs an argument."
        @p.stop
      rescue TypeError
        error("ERROR: Wrong type.")
      rescue ZeroDivisionError
        error("ERROR: Division by zero.")
      rescue FloatDomainError
        error("ERROR: Number out of range.")
      rescue Math::DomainError
        error("ERROR: Number out of domain.")
      end
      puts ret if     $debug and ret.instance_of? String
      puts ret if not $debug and ret.to_s.match(/Error:/)
      @p.flg["22"] = false
      @p.flg["23"] = false
    end
  end
  @p.nolift = false if @nl
  @p.nolift ? @nl = true : @nl = false
  @p.pc += 1 unless ($debug or $prompt)
  @i    += 1 unless ($debug or @i < 0) # Handling of potential infinite loops
  if @i > 1000
    puts "Looped 1000 times. Press 'c' to continue indefinitely or any other key to stop."
    ans = STDIN.getch
    ans == "c" ? @i = -1 : $debug = true
  end
end

# vim: set sw=2 sts=2 et ft=ruby fdm=syntax fdn=2 fcs=fold\:\ :
