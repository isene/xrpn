#!/usr/bin/env ruby
# encoding: utf-8

# GET EXTENSIONS
require 'optparse'
require 'io/console'
require 'date'
require 'bigdecimal'
require 'open-uri'
require 'json'

Dir[Dir.home+"/.xrpn/lib/*"].each { |file| load file } # Read libraries
read_cmd                                               # Read XRPN commands

# INITIALIZE
@p = XRPN.new($rfile)
@p.prg[@p.pg] = ["LBL \"XRPN\"", "END"] unless $rfile   # Put dummy program in page 0 if no file to run
@p.prg[@p.pg] = File.read($lfile).split("\n") if $lfile # Read file to load but not run if -l switch is used
@p.prg[@p.pg] = hp_41(@p.prg[@p.pg])                    # Substitute HP-41 commands with XRPN commands
read_state($sfile) if $sfile                            # Read state file in ~.xrpn/ if -s switch is used
$debug = true      if $lfile or $sfile                  # Do not run loaded program or program in state file
load(Dir.home+'/.xrpn/conf') if File.exist?(Dir.home+'/.xrpn/conf') # Read config file

# THE CORE OF THE RPN PROGRAM
@nl = false # Nolift
@i  = 0     # Counter to prevent infinite loops
until @p.pc == @p.prg[@p.pg].length do
  # Enter debug mode if $debug or $prompt is set, else get next program line
  ($debug or $prompt) ? debug_mode : @line = @p.prg[@p.pg][@p.pc]
  # Split command in maximum three words (e.g. STO IND 13)
  if @line.match(/^-*[\d\.,e]+$/) # If a number is supplied
    @line.sub!(/,/, '.')
    @p.lift
    @p.x = @line.to_f
    @p.flg["22"] = true
    @p.flg["23"] = false
  elsif @line.match(/^".*"/) # If an Alpha string is supplied
    @line.match(/^"\|.*/) ? @p.a += @line.sub(/\|-*/, '').gsub(/\"/, '') : @p.a = @line.gsub(/\"/, '')
    @p.flg["22"] = false
    @p.flg["23"] = true
  else
    l1, l2, l3 = @line.split[0], @line.split[1], @line.split[2]
    l2 = "%02d" % [l2] if l2 == l2.to_i.to_s
    l3 = "%02d" % [l3] if l3 == l3.to_i.to_s
    l2 = ind(l3) if l3 # If middle word is "IND" (or anything actually - since IND is the only possibility)
    if not ($cmd.include?(l1.downcase) or l1.match(/^-*[\d\.,]+$/) or l1.match(/^".*/) ) # Catch unknown command
      puts "No such command: #{l1}"
      @p.stop
    elsif XRPN.method_defined?(l1.downcase) # Or execute the command with either 0, 1 or 2 parameters
      begin
        l2 ? ret = @p.send(l1.downcase, l2) : ret = @p.send(l1.downcase)
      rescue ArgumentError
        puts "Command needs an argument."
      rescue TypeError
        puts "Wrong type."
      rescue Math::DomainError
        puts "Number out of domain."
      end
      puts ret if $debug and ret.instance_of? String
      puts ret if not $debug and ret.to_s.match(/Error:/)
      @p.flg["22"] = false
      @p.flg["23"] = false
    end
  end
  @p.nolift = false if @nl
  @p.nolift ? @nl = true : @nl = false
  @p.pc += 1 unless ($debug or $prompt)
  @i    += 1 unless ($debug or @i < 0) # Handling of potential infinite loops
  if @i > 1000
    puts "Looped 1000 times. Press 'c' to continue indefinitely or any other key to stop."
    ans = STDIN.getch
    ans == "c" ? @i = -1 : $debug = true
  end
end

# vim: set sw=2 sts=2 et ft=ruby fdm=syntax fdn=2 fcs=fold\:\ :
